

In the proposed architecture, the \textit{Smart Gateway} is the central module of the system, connecting the \textit{SmartBoxes} to the \acs{HIS}. It is responsible for the management of devices and their associations -- \textit{SmartBox} to \textit{Biosticker} and \textit{SmartBox} to user -- managing, maintaining and storing the data that is generated by these, as well as handling any communication to and from the \acs{HIS}. 


\paragraph{} Regarding the hardware platform used for the \textit{Smart Gateway}, in the context of the \acs{WoW} project, we use the Intel NUC NUC8i7BEH\footnote{\url{https://ark.intel.com/content/www/us/en/ark/products/126140/intel-nuc-kit-nuc8i7beh.html}}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{images/gateway-image.png}
    \caption[Intel NUC NUC8i7BEH.]{Intel NUC NUC8i7BEH.}
    \label{fig:gateway_image}
\end{figure}


\paragraph{} In the next sections, we propose a service architecture for the \textit{Smart Gateway} in order to fulfill the aforementioned features.

% The \textit{Smart Gateway} maintains a list of all the \textit{SmartBoxes} that are managed by the system, as well as every \textit{Biosticker} and every sensor in the \textit{Biosticker} (which are used to indicate respective biosignal to the \acs{HIS}). 


\section{Service Architecture}

As we have seen, there are multiple key features that form the \textit{Smart Gateway}. From Figure \ref{fig:wow-architecture}, we can list the different \textit{Smart Gateway} components:  

\begin{itemize}
    \item \textbf{Manage devices and device associations}: The \textit{Smart Gateway} maintains a list of all the \textit{SmartBoxes} that are managed by the system, as well as every \textit{Biosticker} and every sensor in the \textit{Biosticker} (which are used to indicate the respective biosignal to the \acs{HIS}). The \textit{Smart Gateway} also tracks the sensor subscriptions per \textit{SmartBox}.
    \item \textbf{Data anonymization}: Any private data (\textit{i.e.} information that can be used to identify a user) that is stored in the \textit{Smart Gateway} is anonymized in order to meet data protection regulations\footnote{Resolution of the Council of Ministers no. 41/2018, of 28 March, following the new General Data Protection Regulation (GDPR), approved by Regulation (EU) 2016/679:  \url{https://dre.pt/application/file/a/114936962\%20}}. 
    \item \textbf{Data pre-processing}: The \textit{Smart Gateway} processes the data as it is collected in order to clean the data before storing it indefinitely, and to detect critical conditions of the patients' state to prompt an immediate notification to the health professionals.
    \item \textbf{Real-time data acquisition}: The \textit{Smart Gateway} handles the secure communications with the \textit{SmartBoxes}, acquiring the data in real-time.
    \item \textbf{Manage data collection}: After receiving and processing the data from the \textit{SmartBoxes}, the \textit{Smart Gateway} stores indefinitely for long-term biomonitoring analytics.
    \item \textbf{\acs{HIS} \acs{FHIR} Integration}: The \textit{Smart Gateway} handles the communication with the \acs{HIS}. More specifically, it processes all \acs{FHIR} requests from the \acs{HIS}, and also transforms the acquired sensor data into \acs{FHIR} messages and communicates it to the \acs{HIS}. 
\end{itemize}

To implement these components, we propose the following service architecture within the \textit{Smart Gateway}, as illustrated in Figure \ref{fig:gateway_serviceoverview}. The correspondence between the services and the \textit{Smart Gateway} components is described in Table \ref{tab:gateway-service}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.93\linewidth]{images/service overview gateway.pdf}
    \caption[Service architecture implemented in the \textit{Smart Gateway}.]{Service architecture implemented in the \textit{Smart Gateway}. The diagram displays the different technologies used throughout the development. The services communicate with each other using Unix Domain Sockets, a Linux protocol for \acf{IPC}.}
    \label{fig:gateway_serviceoverview}
\end{figure}
\begin{table}[H]
    \caption{Correspondence between the \textit{Smart Gateway} services and its functional components.}
    \label{tab:gateway-service}
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{ccc}
    \hline
    \textbf{\textit{Smart Gateway} Component}          & \textbf{\textit{Smart Gateway} Service} & \textbf{Description}                                                                                                                                                             \\ \hline
    Real-time data acquisition             & MQTT Broker                   & \makecell[c]{This service is responsible for handling all the\\  \textit{SmartBoxes} communication, ensuring data\\  encryption, authorization, etc.}                                                           \\ \hline
    Data pre-processing                    & Data processing               & \makecell[c]{This service is handles data filtering and \\ preliminary data processing.}                                                                                                  \\ \hline
    \multirow{3}{*}{\makecell[c]{Manage data collection \\ Manage devices and device associations}}                & \multirow{3}{*}{Data storage} & \multirow{3}{*}{\makecell[c]{This service manages and stores system information,\\ such as the list of devices, permissions of each \\ device and collected sensor data.}} \\
     &                               &                                                                                                                                                                                  \\ & & \\ \hline
    Data anonymization                     & \multirow{2}{*}{FHIR Server}  & \multirow{2}{*}{\makecell[c]{This service is responsible for handling communications \\with the  ``Interoperability'' layer  of \acs{HIS}.}}                                                         \\ 
    \acs{HIS} \acs{FHIR} Integration       &                               &              \\\hline                                                                                                                                                                   
    \end{tabular}
    }
\end{table}

\paragraph{} The services communicate with one another using UNIX Domain Sockets\footnote{\url{https://man7.org/linux/man-pages/man7/unix.7.html}}. This is an interprocess communication (\acs{IPC}) protocol that enables efficient communication between processes running on the same host operative system. This protocol is very efficient, compared for example to traditional network sockets \cite{Wright2007}, since all communication is handled entirely by the operative system kernel, instead of relying on the \acs{IP} protocol stack, minimizing communication overhead. 

The protocol can make use of the Linux file system for addressing the sockets, which means it is subject to Linux file system permissions. This allows applications to identify which process, or more accurately, the user running the process, is attempting to establish a new connection to that application, providing a simple and secure authentication mechanism on the \acs{IPC}.

\section{Data Storage}

The data storage in the \textit{Smart Gateway} is one of the most important components of the device, as it holds the information used by all services in the \textit{Smart Gateway}. Given the importance of this component, it is crucial to use a solution which offers reliability above all, with proved performance for our use case.  

\paragraph{} As discussed in Section \ref{sec:iot-model-layer4}, No\acs{SQL} databases are appealing for \acs{IoT} applications, since these can handle unstructured or semi-structured data and generally better performance than traditional \acs{SQL} databases as the amount of data stored increases. However, these systems are not adequate for a relational data model, which is required to enforce consistent and logical representation of information. For this reason, we decided to move forward with the deployment of a traditional \acs{RDBMS}.

\paragraph{} Out of the different \acs{RDBMS} available in the market, PostgreSQL stands out from the rest due to great overall performance and scalability \cite{Asiminidis2018}. Additionally, it is one of the most popular \acs{RDBMS}\footnote{DB-Engines Monthly Popularity Ranking: \url{https://db-engines.com/en/ranking}}, meaning it also has great community support. 

\paragraph{} With this in mind, we decided to use PostgreSQL for the data storage in the \textit{Smart Gateway}. PostgreSQL\footnote{\url{https://www.postgresql.org}} is an advanced, enterprise-class, and open-source \acs{RDBMS}. It has over 30 years of active development by the open source community, earning a strong reputation for its reliability, feature set and robustness.

\subsection{Database Schema}
Figure \ref{fig:wow-dbschema-full} contains the database model implemented in our PostgreSQL database. It describes all information that is contained in the \textit{Smart Gateway}, the relations within that data, organized according to how that information is used (\textit{i.e.} the service / functionality it is associated with). The data stored in the system can be categorized into 5 distinct groups:

\begin{enumerate}
    \item \textbf{System data} -- Information about the devices which are managed by the system: the \textit{SmartBoxes}, the \textit{Biostickers} and the sensors in each \textit{Biostickers}. 
    \item \textbf{\acs{MQTT} related data} -- Information about the \acs{MQTT} clients and their permissions. 
    \item \textbf{Sensor observation data} -- Biological signals measured and communicated by the \textit{SmartBoxes}.
    \item \textbf{\acs{FHIR} data} -- Data related with \acs{FHIR} communications, such as the subscription requests from the \acs{HIS} to communicate the acquired sensor measurements.
    \item \textbf{Stored procedures} -- Custom subroutines that define the operations used by other services (\textit{e.g.} the \acs{MQTT} broker) to interact with the stored data (insertions, deletions, searches, etc.).
\end{enumerate}

\clearpage 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{images/database-schema-general.pdf}
    \caption[Database model implemented in the \textit{Smart Gateway}.]{Database model implemented in the \textit{Smart Gateway}. The bold text in the diagram is used to denote the Primary Key (PK) of each table. The relationships between entities are indicated with a line and using the symbols ``*'' for many and ``1'' for one.}
    \label{fig:wow-dbschema-full}
\end{figure}

In the next sections, we explore in greater detail the structure of the data within each of these groups.

\subsubsection{System data}
Figure \ref{fig:wow-dbschema-system} describes the components or entities of the database model that depict system information. The data model is designed with flexibility in mind, allowing each \textit{SmartBox} to be associated with any number of \textit{Biostickers}, and each \textit{Biosticker} to have any number of sensors associated with it. Each sensor is associated with an \acs{UUID} in order to uniquely identify the sensor when communicating the sensor measurement to the \acs{HIS}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.55\linewidth]{images/database-schema-system.pdf}
    \caption[Components of the database model used to describe system information.]{
    Components of the database model used to describe system information. As the names suggest, the ``system.biostickers'' table contains the list and details of all \textit{Biostickers}, ``system.smartboxes'' table contains the list and details of all \textit{SmartBoxes}, ``system.biosticker\_sensors'' contains the list and details of all sensors of all \textit{Biostickers}. The ``system.biosticker\_pair\_event'' table is used to track the history of which \textit{Biostickers} were or are currently associated with a specific \textit{SmartBox}.}
    \label{fig:wow-dbschema-system}
\end{figure}

\subsubsection{MQTT related data}

Figure \ref{fig:wow-dbschema-mqtt} describes the information relevant for \acs{MQTT} communications, mostly related with security. To ensure that each device only has access to allowed resources, the system implements a role-based access control (\acs{RBAC}) policy. 
In this type of access control, the system allows or revokes access to resources according to the role of the device, meaning that all devices with a given role share the same list of permissions. The permissions for the \acs{RBAC} policy contain 3 properties: the ID of the role it applies to, the topic name, and the level of access (PUBLISH, SUBSCRIBE and/or READ\footnote{READ access in this context is the ability to receive messages from the broker when subscribed to that topic. SUBSCRIBE access is the ability to issue a subscription request, and PUBLISH the ability to publish messages.}) to be granted (or revoked), as seen in Figure \ref{fig:wow-dbschema-mqtt}. 

\paragraph{} In context of the \acs{WoW} project, the following roles are used:

\begin{itemize}
    \item \textit{SmartBox} role: Indicates that the \acs{MQTT} client is a \textit{SmartBox}.
    \item ``Pyservice'' role: Indicates that the \acs{MQTT} client is actually the data pre-processing service, also contained in the \textit{Smart Gateway}.
    \item Developer device role: Indicates that the \acs{MQTT} client is a developer device, used solely for debugging purposes.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{images/database-schema-mqtt.pdf}
    \caption[Components of the database model used to describe \acs{MQTT} information.]{
    Components of the database model used to describe \acs{MQTT} information. The ``mqtt.roles'' table contains the different \acs{RBAC} roles for the \acs{MQTT} communication and ``mqtt.role\_permissions'' table lists the permissions available to each role using \acs{MQTT} topic wildcards. The ``mqtt.client'' table lists the clients and their properties, such as their \acs{UUID}, the timestamp of their last connection, or a \textit{flag} to indicate if the communication failed during the last communication.}
    \label{fig:wow-dbschema-mqtt}
\end{figure}


\subsubsection{Sensor observation data}

Figure \ref{fig:wow-dbschema-sensors} describes the information associated the sensor measurements collected over time. Each signal measurement is associated with the sensor that measured it and the \textit{SmartBox} that was associated with that sensor, or more accurately associated to the \textit{Biosticker}, at the moment of the observation.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{images/database-schema-sensordata.pdf}
    \caption[Components of the database model used to describe sensor measurements.]{Components of the database model used to describe sensor measurements. The database model has one table for each type of biosignal measured in the \acs{WoW} project (temperature, \acs{ECG}, etc.). The properties of the table are defined according to the structure of the data that is acquired by the \textit{SmartBox}, which are detailed in Section \ref{sec:biosticker_data}. The ``pose\_description'' field in ``sensor\_observations.imu'' table is a text representation of the different body poses according to an international health standard\footnote{\url{https://loinc.org/8361-8/}}. }
    \label{fig:wow-dbschema-sensors}
\end{figure}



\subsubsection{\acs{FHIR} data}

Figure \ref{fig:wow-dbschema-fhir} describes the information associated with the \acs{FHIR} communications. Currently, the only information that is stored in the database is the list of subscription requests sent from the \acs{HIS}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.66\linewidth]{images/database-schema-fhir.pdf}
    \caption[Components of the database model used to describe information used for \acs{FHIR}.]{Components of the database model used to describe information used for \acs{FHIR}. The ``status'' field in the ``fhir.subscription'' table indicates the status of the subscription request (active, completed, revoked, etc.) and should be a text value that matches its equivalent in the \acs{FHIR} enumeration\footnote{\url{https://www.hl7.org/fhir/valueset-request-status.html}}.}
    \label{fig:wow-dbschema-fhir}
\end{figure}

\subsubsection{Stored Procedures}

Since the data storage implemented in the \textit{Smart Gateway} is a \acs{RDBMS}, services that access the database use \acf{SQL} to perform requests, such as retrieving or inserting data. In order to maximize the performance of our data storage solution, we implement ``Stored Procedures'', which are custom subroutines that are stored in the \acs{RDBMS}. These procedures are pre-compiled \acs{SQL} statements, which are simply a set of instructions to execute to perform a given task, that are defined in the \acs{RDBMS}, and can greatly improve the performance of these systems since these:

\begin{itemize}
    \item Reduce significantly the amount of data that is exchanged -- instead of sending a request with a complex \acs{SQL} query to the database, the application sends a request for the execution of a subroutine along with its parameters, thus reducing the size of the request and the time it takes to interpret it.
    \item Reduce significantly the amount of data that is exchanged -- as these \acs{SQL} statements are optimized when pre-compiled.
    \item Increase the security and robustness of the database system -- since the \acs{SQL} statements are pre-compiled, this mitigates possible \acs{SQL} injections attacks \cite{clarke2012sql}, and also providing us with the ability to restrict the permissions of the applications that access the \acs{RDBMS} to execute only certain subroutines, instead of allowing them to perform general \acs{SQL} requests.
\end{itemize}


\section{Connection to the SmartBoxes}

% \acs{MQTT} is a centralized protocol, in which the clients (\textit{SmartBoxes}) connect to a broker, which acts as a middle-man for the communication, managing the requests from all clients accordingly. 

As previously mentioned, the connection to the \textit{SmartBoxes} is performed via \acs{MQTT}. In our system, the \acs{MQTT} broker is contained within the \textit{Smart Gateway}, and is the service responsible for ensuring the communication between the \textit{SmartBoxes} and the \textit{Smart Gateway}.

\paragraph{} To implement this \acs{MQTT} broker, we use the open-source Eclipse Mosquitto\footnote{\url{https://mosquitto.org/}}. Mosquitto is a lightweight \acs{MQTT} broker that supports the \acs{MQTT} protocol versions 5.0, 3.1.1 and 3.1 and is widely used by the community, making it a fitting solution for the \acs{WoW} project. However, in order to implement all security features required, we need to extend its existing functionality, which is discussed in Section \ref{sec:auth_plugin}.

\paragraph{} But first, we need to define the intricacies of the \acs{MQTT} communication between the \textit{SmartBox} and \textit{Smart Gateway}. To this end, we propose a complete specification, detailing the all security measures implemented, the format for the messages exchanged in the communication and the different endpoints (or topics) used. 

\subsection{Proposed \acs{MQTT} Specification}

The \acs{MQTT} standard to be used in all communications is the latest revision\footnote{\url{https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html}}, MQTT 5.0. Additionally, to authenticate and encrypt transmissions between devices, the communication is secured with \acs{TLS} v1.2\footnote{\url{https://tools.ietf.org/html/rfc5246)}} and each \acs{MQTT} client must have its own X.509 V3\footnote{\url{https://tools.ietf.org/html/rfc5280}} certificate and \acs{UUID}, used to uniquely identify it. The aforementioned certificate must have client the \acs{UUID} in the ``Common Name'' field, which is used to ensure that the certificate was issued to that specific \acs{MQTT} client.

\paragraph{} Regarding security, as mentioned previously, the system uses a role-based access control (\acs{RBAC}) policy to authorize access to the \acs{MQTT} topics. This means that devices of the same type (\textit{e.g.} \textit{SmartBoxes}) share the same permissions. 
Nonetheless, we can restrict access of the devices to its own individual topics by including a client \acs{UUID} wildcard in the topic name when assigning the permission.

%This allows the permission list, which are applied at a ``role'' level (\textit{e.g.} that applies to all \textit{SmartBoxes}), to limit the access of the client to only its individual topics by including a client \acs{UUID} wildcard in the topic name on the permission list, since the \acs{UUID} are unique to each client. 



For example, we can define a permission that grants PUBLISH access to the ``smartbox/\%c/temperature'' topic to all \textit{SmartBoxes}, where ``\%c'' is a wildcard for the client \acs{UUID}. This means that a \textit{SmartBox} with client \acs{UUID}\footnote{Although this is not a valid \acs{UUID}, it is used to facilitate the explanation of how topic wildcards work.} ``1'' can publish a message to the topic ``smartbox/1/temperature'', but cannot publish to ``smartbox/2/temperature''.

\clearpage 
\subsubsection{Message Format}
\label{sec:mqtt payload format}
In order to promote interoperability, all messages exchanged in the \acs{MQTT} communication must follow the \acs{JSON} data format. Additionally, these must have the following structure:

\begin{lstlisting}[language=json]
{
    "client_id": client_uuid, 
    "timestamp": timestamp,
    "message_type": message_type,
    "payload": {
        //...
    }, 
}  
\end{lstlisting}

where \textit{client\_id} is the \acs{UUID} of the \acs{MQTT} client, \textit{timestamp} is the UNIX timestamp\footnote{\url{https://www.unixtimestamp.com/}}, and \textit{payload} contains the actual content of the message that is associated to the \textit{message\_type}. The field \textit{message\_type} defines what type of message it is, and must be one of the following:

%\begin{itemize}
%    \item ``MEASUREMENT\_TEMPERATURE'': Indicates that the message is a temperature %measurement.
%    \item ``MEASUREMENT\_IMU'': Indicates that the message is an \acs{IMU} measurement.
%    \item ``MEASUREMENT\_HR'': Indicates that the message is a heart rate measurement.
%    \item ``MEASUREMENT\_ECG'': Indicates that the message is an \acs{ECG} measurement.
%    \item ``MEASUREMENT\_PULSEOXIMETRY'': Indicates that the message is a pulse oximetry %measurement.
%    \item ``MEASUREMENT\_RESPIRATION'': Indicates that the message is a respiratory rate %measurement.
%\end{itemize}


\begin{itemize}
    \item ``MEASUREMENT\_TEMPERATURE'': Indicates that the message is a temperature measurement. The payload format for this message is:
        \begin{lstlisting}[language=json]            
"payload": {
    "temperature" : 10.0,
    "is_celsius" : true 
} 
        \end{lstlisting} 
        where the ``temperature'' field is the temperature measurement, and ``is\_celsius'' field indicates whether the measurement value it is in Celsius or Fahrenheit.
    
    \clearpage
        \item ``MEASUREMENT\_IMU'': Indicates that the message is an \acs{IMU} measurement. The payload format for this message is:
        \begin{lstlisting}[language=json]            
"payload": {
    "imu": {
        "linear_acceleration": {"x": 0.00, "y": 0.00, "z": 0.00},
        "angular_velocity": {"x": 0.00, "y": 0.00, "z": 0.00} 
    }
        "pose_description" : "SITTING"
} 
        \end{lstlisting} 
        where the ``linear\_acceleration'' field is the accelerometer measurement,``angular\_velocity'' field is the gyroscope measurement, and ``pose\_description'' is the text description of the current body pose of the patient.

    \item ``MEASUREMENT\_ECG'': Indicates that the message is an \acs{ECG} measurement. The payload format for this message is:
        \begin{lstlisting}[language=json]            
"payload": {
    "ecg" : 10
} 
        \end{lstlisting} 
        where the ``ecg'' field is the \acs{ECG} measurement.
    \item ``MEASUREMENT\_PULSEOXIMETRY'': Indicates that the message is a pulse oximetry measurement. The payload format for this message is:
        \begin{lstlisting}[language=json]            
"payload": {
    "spo2" : 10.0
} 
        \end{lstlisting} 
        where the ``spo2'' field is the pulse oximetry measurement.


    \item ``MEASUREMENT\_HR'': Indicates that the message is a heart rate measurement. The payload format for this message is:
        \begin{lstlisting}[language=json]            
"payload": {
    "bpm" : 10.0
} 
        \end{lstlisting} 
        where the ``bpm'' field is the heart rate measurement.


    \item ``MEASUREMENT\_RESPIRATION'': Indicates that the message is a respiratory rate measurement. The payload format for this message is:
        \begin{lstlisting}[language=json]            
"payload": {
    "respiration" : 10.0
} 
        \end{lstlisting} 
        where the ``respiration'' field is the respiration rate measurement.
\end{itemize}
\subsubsection{Data endpoints}
To communicate the sensor data, the \textit{SmartBox} must publish to different endpoints, depending on the type of sensor data that is transmitted:

\begin{itemize}
    \item \textbf{Temperature} data: ``smartbox/\%c/temperature''.
    \item \textbf{\acf{IMU}} data: ``smartbox/\%c/imu''.
    \item \textbf{\acf{ECG}} data: ``smartbox/\%c/ecg''.
    \item \textbf{Pulse Oximetry} data: ``smartbox/\%c/pulseoximetry''.
    \item \textbf{Heart Rate} data: ``smartbox/\%c/heartrate''.
    \item \textbf{Respiration Rate} data: ``smartbox/\%c/respiration''.
\end{itemize}

%\subsubsection{Redundancy endpoints}
% - When initiating the connection, the smartbox must define an [KeepAlive](https://docs.% oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html#_Toc3901045) interval and a [Will Message]% (https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc479576982);
% - The topic used for publishing the will message must be `smartbox/$smartbox_uuid$/ltt`.
% - The content of the Will Message will be defined later.
% - When the smartbox reconnects to the broker after a unexpected disconnection, the broker % must send a sync request (`SYNC_REQ`) to the smartbox in the topic `smartbox/$smartbox_id$/% sync`. The smartbox must reply (`SYNC_REP`) by sending every measure registered after the % given timestamp in the topic `smartbox/$smartbox_id$/sync/response`.
%   - The following example shows the message flow for a given sync request:
% 
%      ```json
%      /* Pedido de sincronização 
%      * Publicado pelo servidor no tópico: smartbox/123e4567-e89b-12d3-a456-426655440000/sync
%      */
%      {
%          "client_id": "123e4567-e89b-12d3-a456-426655440000", 
%          "timestamp": 1614884856,
%          "message_type": "SYNC_REQ",
%          "payload": {
%              "lastMessageTimestamp": 16148840000
%          }, 
%      }
% 
%      /* Resposta ao pedido de sincronização 
%      * Publicado pela smartbox no tópico: smartbox/123e4567-e89b-12d3-a456-426655440000/sync/% response
%      */
%      {
%          "client_id": "123e4567-e89b-12d3-a456-426655440000",
%          "timestamp": 1614884856,
%          "message_type": "SYNC_RESP",
%          "payload": {
%              [
%                  /* Lista de mensagens em backlog (estas não precisam de conter o client_id) % */
%                  {   
%                      "timestamp": 16148840000,
%                      "message_type": "MEASUREMENT_TEMPERATURE",
%                      "payload": {
%                          "data": 10.3
%                      }
%                  }, 
%                  {   
%                      "timestamp": 16148840001,
%                      "message_type": "MEASUREMENT_TEMPERATURE",
%                      "payload": {
%                          "data": 10.4
%                      }
%                  }, 
%                  
%                  /* ... */
%              ]
%          }, 
%      }
%      ```
\subsection{Authorization and Authentication Plugin}
\label{sec:auth_plugin}

One of the major flaws of Mosquitto is that it does not supply proper dynamic authentication and authorization mechanisms for the \acs{MQTT} communication out-of-the box. By default, the list of \acs{MQTT} authorized clients and their permissions are static, defined by a configuration file which is processed at the start of the program\footnote{\url{https://mosquitto.org/man/mosquitto-conf-5.html}}. In order to implement proper security measures, Mosquitto exposes an extensive plugin \acs{API}\footnote{\url{https://mosquitto.org/api/files/mosquitto\_plugin-h.html})} that covers authentication, access control, and message inspection and modification; which was used to develop our own custom plugin to fulfill the security requirements for the \acs{WoW} project. The code for the plugin can be found here\footnote{\url{https://github.com/WoW-Institute-of-Systems-and-Robotics/mosquitto-auth-plugin}}.

\paragraph{} The plugin works by intercepting authorization and authentication requests from the \acs{MQTT} broker, and validating the information in them. Figure \ref{fig:mqtt-plugin-authnflow} describes how a client is authorized by the \acs{MQTT} broker, and Figure \ref{fig:mqtt-plugin-authzflow} describes how a client's request is authorized using this plugin.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{images/mqtt authentication.pdf}
    \caption[Flowchart describing how a \acs{MQTT} client is authenticated by the \acs{MQTT} broker.]{Flowchart describing how a \acs{MQTT} client is authenticated by the \acs{MQTT} broker. The process start with the X.509 certificate validation at the \acs{TLS} layer. If the certificate is valid, Mosquitto proceeds by sending an authentication request for that client to the plugin. In the plugin, we validate the X.509 certificate information, in particular the ``Common Name'' field, and ensure the client is registered in the database.}
    \label{fig:mqtt-plugin-authnflow}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{images/mqtt authorization.pdf}
    \caption[Flowchart describing how a PUBLISH request from an authenticated \acs{MQTT} client is authorized by the \acs{MQTT} broker.]{Flowchart describing how an authenticated \acs{MQTT} client's request is authorized by the \acs{MQTT} broker. Since the client is already authenticated, Mosquitto proceeds by sending an authorization request for that client to the plugin. The plugin requests the list of permissions associated with the client role, and then checks if any permission on that list explicitly grants PUBLISH access to the topic.}
    \label{fig:mqtt-plugin-authzflow}
\end{figure}
\section{Data pre-processing}

The Data pre-processing service is used to process the incoming data from the \textit{SmartBoxes} in real-time. It subscribes to incoming \acs{MQTT} messages using a \acs{MQTT} client with superuser privileges to have access to all topics. It validates the \acs{MQTT} messages according to the message formats specified in Section \ref{sec:mqtt payload format}, filters any irrelevant information, and stores it in the database. Currently, it does not apply any data analytics to detect critical conditions. The code for the service can be found here\footnote{\url{https://github.com/WoW-Institute-of-Systems-and-Robotics/gateway_pyservice}}. 

\paragraph{} Figure \ref{fig:dataprocess_flowdiagram} shows how incoming data is processed by the service. 

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{images/data pre processing.pdf}
    \caption[Flowchart describing how incoming \acs{MQTT} messages are processed by the data pre-processing service.]{Flowchart describing how incoming \acs{MQTT} messages are processed by the data pre-processing service.}
    \label{fig:dataprocess_flowdiagram}
\end{figure}

\section{\acs{HIS} \acs{FHIR} Integration}
The \acs{HIS} \acs{FHIR} Integration service is used to manage the communication to and from GlobalCare \acs{HIS}. The service must implement a \acs{FHIR} \acs{HTTP} server\footnote{\url{https://www.hl7.org/fhir/http.html}} capable of handling requests from the \acs{HIS}, as well as transform the sensor measurement data into \acs{FHIR} messages and communicate it to the \acs{HIS}.

\paragraph{} Out of the open-source implementations of the \acs{FHIR} specification available\footnote{\url{https://confluence.hl7.org/pages/viewpage.action?pageId=35718838}}
, the HAPI-FHIR Java library\footnote{\url{https://hapifhir.io}} is one of the longest supported \acs{FHIR} implementations, with over 18 years of active development. The project is backed and maintained by Smile CDR\footnote{\url{https://www.smilecdr.com}}, a health technology company with a long-standing reputation in the health \acs{IT} field. Additionally, it is a Java library, which is a programming language used by the author, in contrast to other available implementations.

\paragraph{} Thus, we decided to use HAPI-FHIR Java library to implement the \acs{FHIR} server. The HAPI-FHIR library provides a simple and intuitive \acs{API} to interact with \acs{FHIR} Resources\footnote{\url{https://www.hl7.org/fhir/resource.html}}, which are the objects used to exchange data in the protocol.

\paragraph{} HAPI-FHIR provides several mechanisms to build \acs{FHIR} \acs{HTTP} servers. In our case, we use Plain Server implementation\footnote{\url{https://hapifhir.io/hapi-fhir/docs/server_plain/introduction.html}} to develop our \acs{FHIR} server. Using this implementation, we only need to implement the logic associated with the interactions to the data storage solution, while the HAPI-FHIR ensures all the \acs{HTTP} processing, as well as parsing and serialization of data into \acs{FHIR} resources.

\paragraph{} The \acs{HAPI-FHIR} Plain Server implementation is based on Java Servlet  	
3.1 \acs{API}\footnote{\url{https://docs.oracle.com/javaee/7/tutorial/servlets.htm}}. Servlets, in short, are applications that are hosted on web servers, used to extend their capabilities. 

\paragraph{} In order to have a functional \acs{FHIR} server, we need a web server capable of hosting the \acs{HAPI-FHIR} Plain Server servlet.
\subsection{FHIR Server}


% Ver especificação que a Glintt enviou com as mensagens se quiseres colocar exemplos de mensagens para cada sensor.

A service was developed for the gateway which handles all FHIR communications. The service is an Java EE Servlet container, which was developed using HAPI-FHIR library\footnote{\url{https://hapifhir.io}}, an open-source implementation of the FHIR specification in Java. 

The servlet is composed of three major components:
\begin{itemize}
    \item ``Resource Providers'' - which define the different interactions which are supported by our \acs{FHIR} server and invoke the CRUD (create, read, update and delete) operations over our arbitrary data store through the ``Database Handler'';
    \item ``Database Handler'' - which defines how the \acs{FHIR} server connects to the data storage solution, which implements and exposes the methods used by the ``Resource Providers'' to interact with the data. This component is also responsible for translating the data, as its stored in the data storage solution into valid \acs{FHIR} resources and vice versa;
    \item ``Subscription Handler'' - which handles the transmission of sensor data to the \acs{HIS} through \acs{FHIR} Observations\footnote{\url{https://www.hl7.org/fhir/observation.html}}. The scheduling of the transmission tasks is performed using the Quartz Scheduler library\footnote{\url{http://www.quartz-scheduler.org/}}.
\end{itemize}


- Falar do que são os FHIR Resources, e mais especificamente dos Resources usados para transmitir os dados -> Bundle, Device, Observation
- Apresentação do diagrama de comunicação de informação

\subsubsection{Resource Providers}

\subsubsection{Database Handler}

\subsubsection{Subscription Handler}
In order to have a functional system for a stable version, only part of FHIR specification was implemented, which was the transmission of \textit{Observations} as a result of a \textit{ServiceRequest}. In this version, all associations between patients and smartboxes and \textit{ServiceRequests} were pre-configured. Additionally, the authentication protocol used was Basic Authentication instead of \textit{OAuth2}, in this initial phase.

As defined previously, the transmission of \textit{Observations} by gateway is performed by sending a \textit{Bundle resource} \footnote{\url{https://www.hl7.org/fhir/bundle.html}}to the base URL of the HIS FHIR server, which must contain the \textit{Observations resource} itself, the \textit{Device resource} representing the Smart Box and also representing the sensor that reported this observation.

\section{Summary}

In this chapter, we presented the different components which form the \textit{Smart Gateway}. In the chapter, we evaluate the performance of our proposed solution through a hospital trial.